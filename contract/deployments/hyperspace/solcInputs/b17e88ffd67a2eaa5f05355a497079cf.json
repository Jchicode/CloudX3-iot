{
  "language": "Solidity",
  "sources": {
    "contracts/SBT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ncontract STCDao {\n\n    struct Soul {\n        string identity;\n        // add issuer specific fields below\n        string url;\n        uint256 score;\n        uint256 timestamp;\n    }\n\n    struct Dao {\n        string name;\n        string description;\n        string jsoninfo;\n    }\n\n    Dao [] daoArr;\n\n    mapping (address => Soul) private souls;\n    mapping (address => mapping (address => Soul)) soulProfiles;\n    mapping (address => address[]) private profiles;\n\n    address public operator;\n    bytes32 private zeroHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    \n    event Mint(address _soul);\n    event Burn(address _soul);\n    event Update(address _soul);\n    event SetProfile(address _profiler, address _soul);\n    event RemoveProfile(address _profiler, address _soul);\n\n    constructor() {\n      operator = msg.sender;\n    }\n\n    function createDao(string memory name, string memory description, string memory jsoninfo) external {\n//        require(keccak256(bytes(souls[_soul].identity)) == zeroHash, \"Soul already exists\");\n//        require(msg.sender == operator, \"Only operator can mint new souls\");\n        daoArr.push(Dao(name, description, jsoninfo));\n//        emit Mint(_soul);\n    }\n\n    function getDao() external view returns (Dao[] memory) {\n        return daoArr;\n    }\n\n    function mint(address _soul, Soul memory _soulData) external {\n        require(keccak256(bytes(souls[_soul].identity)) == zeroHash, \"Soul already exists\");\n        require(msg.sender == operator, \"Only operator can mint new souls\");\n        souls[_soul] = _soulData;\n        emit Mint(_soul);\n    }\n\n    function burn(address _soul) external {\n        require(msg.sender == _soul || msg.sender == operator, \"Only users and issuers have rights to delete their data\");\n        delete souls[_soul];\n        for (uint i=0; i<profiles[_soul].length; i++) {\n            address profiler = profiles[_soul][i];\n            delete soulProfiles[profiler][_soul];\n        }\n        emit Burn(_soul);\n    }\n\n    function update(address _soul, Soul memory _soulData) external {\n        require(msg.sender == operator, \"Only operator can update soul data\");\n        require(keccak256(bytes(souls[_soul].identity)) != zeroHash, \"Soul does not exist\");\n        souls[_soul] = _soulData;\n        emit Update(_soul);\n    }\n\n    function hasSoul(address _soul) external view returns (bool) {\n        if (keccak256(bytes(souls[_soul].identity)) == zeroHash) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function getSoul(address _soul) external view returns (Soul memory) {\n        return souls[_soul];\n    }\n\n    /**\n     * Profiles are used by 3rd parties and individual users to store data.\n     * Data is stored in a nested mapping relative to msg.sender\n     * By default they can only store data on addresses that have been minted\n     */\n    function setProfile(address _soul, Soul memory _soulData) external {\n        require(keccak256(bytes(souls[_soul].identity)) != zeroHash, \"Cannot create a profile for a soul that has not been minted\");\n        soulProfiles[msg.sender][_soul] = _soulData;\n        profiles[_soul].push(msg.sender);\n        emit SetProfile(msg.sender, _soul);\n    }\n\n    function getProfile(address _profiler, address _soul) external view returns (Soul memory) {\n        return soulProfiles[_profiler][_soul];\n    }\n\n    function listProfiles(address _soul) external view returns (address[] memory) {\n        return profiles[_soul];\n    }\n\n    function hasProfile(address _profiler, address _soul) external view returns (bool) {\n        if (keccak256(bytes(soulProfiles[_profiler][_soul].identity)) == zeroHash) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function removeProfile(address _profiler, address _soul) external {\n        require(msg.sender == _soul, \"Only users have rights to delete their profile data\");\n        delete soulProfiles[_profiler][msg.sender];\n        emit RemoveProfile(_profiler, _soul);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}